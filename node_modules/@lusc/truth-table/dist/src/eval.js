import {} from './parse-operation.js';
import { operationToString } from './operation-to-string.js';
import { Operator } from './operators.js';
export const operations = {
    iff: (a, b) => a === b,
    ifthen: (a, b) => !a || b,
    not: (a) => !a,
    and: (a, b) => a && b,
    nand: (a, b) => !(a && b),
    xor: (a, b) => (a ? !b : b),
    or: (a, b) => a || b,
    nor: (a, b) => !(a || b),
};
export const evalOperation = (operation, variables) => {
    const stringified = operationToString(operation);
    let cached = variables[stringified];
    if (cached !== undefined) {
        return cached;
    }
    switch (operation.type) {
        case 'variable': {
            cached = variables[operation.variable];
            break;
        }
        case 'operator': {
            if (operation.operator === Operator.not) {
                cached = operations.not(evalOperation(operation.values[0], variables));
            }
            else {
                cached = operations[operation.operator](evalOperation(operation.values[0], variables), evalOperation(operation.values[1], variables));
            }
            break;
        }
        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
        default: {
            throw new Error(`Unexpected operation.type "${operation?.type}".`);
        }
    }
    variables[stringified] = cached;
    return cached;
};
//# sourceMappingURL=eval.js.map