import { IndexedError } from './indexed-error.js';
import { Operator } from './operators.js';
import { operatorAliases, singleCharacterNotAliases } from './operator-alias.js';
const VARIABLES_RE = /^[a-z_]+$/i;
const PARENS_RE = /^[()]+$/;
export var TokenType;
(function (TokenType) {
    TokenType["variable"] = "variable";
    TokenType["operator"] = "operator";
    TokenType["parens"] = "parens";
})(TokenType || (TokenType = {}));
function tokenizeOperator(characters, from, to, source) {
    const result = [];
    while (characters.length > 0
        && singleCharacterNotAliases.has(characters.at(-1))) {
        result.unshift({
            type: TokenType.operator,
            operator: Operator.not,
            from: to - 1,
            to,
            source,
        });
        --to;
        characters = characters.slice(0, -1);
    }
    if (characters.length > 0) {
        const operator = operatorAliases.get(characters.toLowerCase());
        if (!operator) {
            throw new IndexedError(`Unknown operator "${characters}".`, from, to);
        }
        result.unshift({
            type: TokenType.operator,
            operator,
            from,
            to,
            source,
        });
    }
    return result;
}
export const tokenize = (input) => {
    input = input.normalize('NFKC');
    const result = [];
    for (const match of input.matchAll(/[a-z_]+|[()]|[^a-z_()\s]+/gi)) {
        const characters = match[0];
        const from = match.index;
        if (typeof from !== 'number') {
            throw new TypeError('Expected a number on match.index');
        }
        const to = from + characters.length;
        if (VARIABLES_RE.test(characters)) {
            // Handle things like "and"
            if (operatorAliases.has(characters.toLowerCase())) {
                result.push({
                    type: TokenType.operator,
                    operator: operatorAliases.get(characters.toLowerCase()),
                    from,
                    to,
                    source: input,
                });
            }
            else {
                result.push({
                    type: TokenType.variable,
                    characters: characters.toUpperCase(),
                    from,
                    to,
                    source: input,
                });
            }
        }
        else if (PARENS_RE.test(characters)) {
            result.push({
                type: TokenType.parens,
                parensType: characters === '(' ? 'open' : 'close',
                from,
                to,
                source: input,
            });
        }
        else {
            result.push(...tokenizeOperator(characters, from, to, input));
        }
    }
    return result;
};
//# sourceMappingURL=tokenize.js.map